import { readFile, copyFile, readdir, stat } from "node:fs/promises";
import { join, basename, extname } from "node:path";
import { config } from "../config.js";
import { ValidationError, ModelError } from "../utils/errors.js";
import { logger } from "../utils/logger.js";

function getInputDir(): string {
  if (!config.comfyuiPath) {
    throw new ValidationError(
      "COMFYUI_PATH is not configured. Set the COMFYUI_PATH environment variable.",
    );
  }
  return join(config.comfyuiPath, "input");
}

function getOutputDir(): string {
  if (!config.comfyuiPath) {
    throw new ValidationError(
      "COMFYUI_PATH is not configured. Set the COMFYUI_PATH environment variable.",
    );
  }
  return join(config.comfyuiPath, "output");
}

/**
 * Copy a local image file into ComfyUI's input/ directory so it can be
 * referenced by LoadImage nodes in workflows.
 */
export async function uploadImage(
  sourcePath: string,
  filename?: string,
): Promise<{ filename: string; path: string }> {
  const inputDir = getInputDir();
  const resolvedFilename = filename ?? basename(sourcePath);

  // Validate extension
  const ext = extname(resolvedFilename).toLowerCase();
  const allowed = [".png", ".jpg", ".jpeg", ".webp", ".bmp", ".gif", ".tiff", ".tif"];
  if (!allowed.includes(ext)) {
    throw new ValidationError(
      `Unsupported image format "${ext}". Supported: ${allowed.join(", ")}`,
    );
  }

  const targetPath = join(inputDir, resolvedFilename);
  logger.info("Uploading image to ComfyUI input", { sourcePath, targetPath });

  try {
    await copyFile(sourcePath, targetPath);
  } catch (err) {
    throw new ValidationError(
      `Failed to copy image: ${err instanceof Error ? err.message : err}`,
    );
  }

  return { filename: resolvedFilename, path: targetPath };
}

/**
 * Extract embedded workflow JSON from a ComfyUI-generated PNG file.
 * ComfyUI stores workflow data in PNG tEXt chunks under the keys
 * "prompt" (API format) and "workflow" (UI format).
 */
export async function extractWorkflowFromImage(
  imagePath: string,
): Promise<{ prompt?: Record<string, unknown>; workflow?: Record<string, unknown> }> {
  const ext = extname(imagePath).toLowerCase();
  if (ext !== ".png") {
    throw new ValidationError(
      "Workflow extraction only works with PNG files. ComfyUI embeds metadata in PNG tEXt chunks.",
    );
  }

  const buffer = await readFile(imagePath);
  const result: { prompt?: Record<string, unknown>; workflow?: Record<string, unknown> } = {};

  // Parse PNG chunks to find tEXt/iTXt chunks with "prompt" or "workflow" keys
  const chunks = parsePngTextChunks(buffer);

  for (const { keyword, text } of chunks) {
    if (keyword === "prompt") {
      try {
        result.prompt = JSON.parse(text);
      } catch {
        logger.warn("Failed to parse 'prompt' PNG metadata as JSON");
      }
    } else if (keyword === "workflow") {
      try {
        result.workflow = JSON.parse(text);
      } catch {
        logger.warn("Failed to parse 'workflow' PNG metadata as JSON");
      }
    }
  }

  if (!result.prompt && !result.workflow) {
    throw new ValidationError(
      "No ComfyUI workflow metadata found in this PNG. The image may not have been generated by ComfyUI, or metadata embedding may have been disabled.",
    );
  }

  return result;
}

interface PngTextChunk {
  keyword: string;
  text: string;
}

/**
 * Low-level PNG tEXt/iTXt chunk parser.
 * PNG format: 8-byte signature, then chunks of [4-byte length][4-byte type][data][4-byte CRC].
 */
function parsePngTextChunks(buffer: Buffer): PngTextChunk[] {
  const results: PngTextChunk[] = [];

  // Verify PNG signature
  const PNG_SIG = Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]);
  if (buffer.length < 8 || !buffer.subarray(0, 8).equals(PNG_SIG)) {
    throw new ValidationError("Not a valid PNG file");
  }

  let offset = 8; // Skip signature

  while (offset + 8 <= buffer.length) {
    const chunkLength = buffer.readUInt32BE(offset);
    const chunkType = buffer.subarray(offset + 4, offset + 8).toString("ascii");
    const dataStart = offset + 8;
    const dataEnd = dataStart + chunkLength;

    if (dataEnd > buffer.length) break;

    if (chunkType === "tEXt") {
      // tEXt: keyword\0text
      const data = buffer.subarray(dataStart, dataEnd);
      const nullIdx = data.indexOf(0);
      if (nullIdx >= 0) {
        const keyword = data.subarray(0, nullIdx).toString("latin1");
        const text = data.subarray(nullIdx + 1).toString("latin1");
        results.push({ keyword, text });
      }
    } else if (chunkType === "iTXt") {
      // iTXt: keyword\0compressionFlag\0compressionMethod\0languageTag\0translatedKeyword\0text
      const data = buffer.subarray(dataStart, dataEnd);
      const nullIdx = data.indexOf(0);
      if (nullIdx >= 0) {
        const keyword = data.subarray(0, nullIdx).toString("utf-8");
        const compressionFlag = data[nullIdx + 1];
        // Skip compression method (1 byte), language tag, translated keyword
        let textStart = nullIdx + 3; // past null, compressionFlag, compressionMethod
        // Skip language tag (null-terminated)
        const langEnd = data.indexOf(0, textStart);
        if (langEnd >= 0) {
          textStart = langEnd + 1;
          // Skip translated keyword (null-terminated)
          const transEnd = data.indexOf(0, textStart);
          if (transEnd >= 0) {
            textStart = transEnd + 1;
          }
        }
        const textData = data.subarray(textStart);
        if (compressionFlag === 0) {
          results.push({ keyword, text: textData.toString("utf-8") });
        }
        // We skip compressed iTXt chunks â€” ComfyUI typically uses uncompressed
      }
    }

    if (chunkType === "IEND") break;

    // Next chunk: length(4) + type(4) + data(chunkLength) + CRC(4)
    offset = dataEnd + 4;
  }

  return results;
}

export interface OutputImage {
  filename: string;
  path: string;
  size: number;
  modified: string;
}

/**
 * List images in the ComfyUI output directory.
 */
export async function listOutputImages(options?: {
  limit?: number;
  pattern?: string;
}): Promise<OutputImage[]> {
  const outputDir = getOutputDir();
  const limit = options?.limit ?? 20;
  const pattern = options?.pattern?.toLowerCase();

  let entries: string[];
  try {
    entries = await readdir(outputDir);
  } catch {
    return [];
  }

  const imageExts = new Set([".png", ".jpg", ".jpeg", ".webp"]);
  const images: OutputImage[] = [];

  for (const entry of entries) {
    const ext = extname(entry).toLowerCase();
    if (!imageExts.has(ext)) continue;
    if (pattern && !entry.toLowerCase().includes(pattern)) continue;

    const filePath = join(outputDir, entry);
    try {
      const info = await stat(filePath);
      if (!info.isFile()) continue;
      images.push({
        filename: entry,
        path: filePath,
        size: info.size,
        modified: info.mtime.toISOString(),
      });
    } catch {
      continue;
    }
  }

  // Sort newest first
  images.sort((a, b) => b.modified.localeCompare(a.modified));

  return images.slice(0, limit);
}
